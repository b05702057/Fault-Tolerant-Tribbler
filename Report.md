# Report

## Bin Storage
Since it is easier to maintain data in the same bin for migration, we hash the bin name with default_hasher to determine target backends to store data. Every time we try to find the target backend, we first hash the bin name with the number of possible backends and then using the index in all the backends ad the lower bound to get hte consistent hash. For migration, we first get all the keys and list keys, extract bin names, and hash it to see if it is the target item for migration. Also, we consider all the data in  one bin as a group and migrate these data together. To deal with concurrent operation executions, we use two list which are prefix list and suffix list. Therefore, migration will not write to the same list with the frontend client. We do deduplication after concatinate two lists and order the list with the index that has been write to primary list. We consider the the lower bound index after hashing as best fit, and its succesor as backup. However, if we detect that backend has longer list, we will switch the primary and backup since this will only happen when the primary just join and has not finish migration. After fetching the two lists, we truncated the prefix, concatinate the two list as total list and sort total list by the index of the item that just added to primary list. 

## Keeper
We rely on keeper to sync clock and do the migration between backends when new backend joins or backend crashes. One keeper is distrubuted to be responsible for syncing and migration of a range of backends. 
